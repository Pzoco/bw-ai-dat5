\section{Implementing potential fields}
	
	\subsection{General structure}
	%TALK ABOUT 
	%initialization.
	 %_variables
	 %_parameters
		
	
	The potential field is calculated for individual units. These units belongs to a squad, when we calculate the potential field we allso pass a refrence to the squad, called \textit{mySquad}, because it is needed to calculate \textit{Squad center} and \textit{Ally potential}.

\begin{Sourcecode}[caption=Main loop]	
(*@\lnote@*)BaseTactic::InitializeParameters(mySquad);
Position centerPosition = _unit->getPosition();
(*@\lnote@*)std::list<BWAPI::Position> listOfPositions = MathHelper::GetSurroundingPositions(centerPosition,48);
BWAPI::Position bestQPosistion = BWAPI::Position(1,1);
(*@\lnote@*)double centerQ = BaseTactic::CalculateQPotentialField(_unit->getPosition(),false);
double higestQfound; 
bool firstCalculation = true;
(*@\lnote@*)for each(BWAPI::Position position in listOfPositions)
{
	double currentQ = BaseTactic::CalculateQPotentialField(position,false);
	(*@\lnote@*)if(firstCalculation)
	{
		firstCalculation = false;
		higestQfound = currentQ;
		bestQPosistion = position;
	} 
	if(currentQ > higestQfound)
	{
		higestQfound = currentQ;
		bestQPosistion = position;
	}
	//used to print the potential arround the unit
	Broodwar->drawTextMap(position.x(),position.y(),"%d",(int)currentQ); 
}
(*@\lnote@*)if(centerQ == higestQfound)
{
	bestQPosistion = centerPosition;
}
\end{Sourcecode}	
	In \lnnum{1} we initialize all the parameters that we only need to calculate ones for all tiles:
	\begin{itemize}
	    \item int da - Is the distance to closed ally unit.
		\item int ds - The distance from center of army to unit.
		\item int sv - The units maximum shooting range. -1 if there is no weapon for this type.
		\item int sva - The eunits maximum shooting range for air. -1 if there is no weapon for this type.
		\item int de - Distance to nerest known enemy.
		\item bool wr - A boolean denoting whether or not the weapons are ready to fire.
		\item BWAPI::Position squadPos - The center of the squad.
	\end{itemize}
	
	
    Next, we need to find the tiles we want to calculate the potential for. This is done useing the \textit{MathHelper::GetSurroundingPositions}  function in \lnnum{2}. This function takes two parameters, the tile the unit is currently on and the distance to the center of the adjecent tiles. From this we calculate all tiles arround the unit and and them to a list.

    Now in \lnnum{3} we calculate the potential for the center tile, this is used in \lnnum{6} to compare it to the best potential found, if the are equal we choose the center tile. This is a rare case and mostly accure when all the potential fields are zero, in that case we dont want to move, if we didnt choose to make \textit{bestQPosistion} the \textit{centerPosition} and returned any other tile, the unit would move to this tile.
    
    In \lnnum{4} we have the main loop. This loop iterates trough all the tiles arround our unit and selects the highest one. There is one special case in \lnnum{5}, this is the first calculate. In the first calculaten we allways select it as the current best option. This is done just so we have something to compare with rather then just set it to an arbitrary tile and number.
	
	
	\subsection{Squad center}	
		\begin{Sourcecode}[caption=Squad center]
(*@\lnote@*)_parameters.dsv = pos.getApproxDistance(_parameters.squadPos);	
int useSquad = 0;
(*@\lnote@*)if(_parameters.ds > _variables.SQUADDISTANCE_CONSTANT)
	useSquad = 1;

(*@\lnote@*)squad += ((double)_variables.FORCESQUAD * (2*(double)_parameters.ds-(double)_parameters.dsv))*useSquad;
(*@\lnote@*)squadQ += (2*(double)_parameters.ds-(double)_parameters.dsv)*useSquad;
\end{Sourcecode}
		In \lnnum{1} we calculate \textit{dsv} by using the build in function getApproxDistance which returns the distance between two tiles as an integer. \textit{pos} is the current tile we want to calculate the potential for and \textit{squadPos} is the tile in the center of the squad.
		
		Then in \lnnum{2} we check weather or not to use the \textit{Squad center} which depends on the distance from the unit, know as \textit{ds}, to the center of the squad. This is used to handle the two cases found in the design of the potential field.
		
		Afterwards we calculate the potential in \lnnum{3} where \textit{\_variables.FORCESQUAD} is $f_{S}$. Unlike in the design we times useSquad on the end, this is to make it zero if we don't want to use potential field, which would make the entire calculation become zero. This is way to control the use of the potential field is not only used in \textit{Squad center} but also in all the other potential fields.
		
		\textit{squadQ} in \lnnum{4} and likewise will be explained in the implementation of reinforcement learning in section \ref{section:reinforcement} !!!!!!!!!!!!!!!!!!!!!!!! FIX REF !!!!!!!!!!!!!!!
		
		The \textit{Squad center} implemented and running can be seen in figure \ref{fig:SCA}.
\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Squadcenter.png}
			{Squad center}{fig:SCA}{-3in}
			
	\subsection{Maximum distance positioning}
		\begin{Sourcecode}[caption=Maximum distance]
(*@\lnote@*)int distanceToEnemyFromUnit = _parameters.de;
(*@\lnote@*)_parameters.due = MathHelper::GetDistanceToNearestEnemy(pos);
(*@\lnote@*)int correctedDistance = (2*_parameters.de - _parameters.due);
int useMaxDist = 1;
if(_parameters.sv > distanceToEnemyFromUnit)
	useMaxDist = 0;

(*@\lnote@*)maxdist += ((double)_variables.FORCEMAXDIST * (double)correctedDistance)*(double)useMaxDist;
maxdistQ += (double)(correctedDistance)*(double)useMaxDist;
\end{Sourcecode}
	%TEXT
	
	In \textit{Maximum distance positioning} we start by calculating \textit{de} and \textit{due}in \lnnum{1} \lnnum{2}. These are used to calculate $(2*de - due)$ in \lnnum{3}, known in the code as \textit{correctedDistance}. 
	
	\textit{correctedDistance} is being calculated even if we don't use \textit{Maximum distance positioning} because its also used in \textit{Weapon cool down}. 
	
	In \lnnum{1} and \lnnum{2} we make use of \textit{MathHelper::GetDistanceToNearestEnemy} which is a function that takes a tile as input, and then iterates trough all visible enemies and calculates the distance to there nearest one, and returns it.
	
	The last thing is calculating the potential which is done in \lnnum{4}. The \textit{Maximum distance positioning} implemented and running can be seen in figure \ref{fig:MDP}.

	
	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/MaximumDistance.png}
			{Maximum distance positioning}{fig:MDP}{-3in}

	\subsection{Weapon cool down}
		\begin{Sourcecode}[caption=Weapon cool down]
int toCool = 1;
if(_parameters.wr)
	toCool = 0;
	
cool += _variables.FORCECOOLDOWN*correctedDistance*toCool;
coolQ += correctedDistance*toCool;
\end{Sourcecode}	
	\textit{Weapon cool down} looks a lot like \textit{Maximum distance positioning} and the do almost the same thing, the only difference is when they are applied. An example of \textit{Weapon cool down} can be found in figure \ref{fig:WCD}.
	
	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Weaponscooldown.png}
		{Repulsion from Weapons cool down}{fig:WCD}{-3in}

	\subsection{Ally units}
		\begin{Sourcecode}[caption=Ally units]
(*@\lnote@*)_parameters.dua = MathHelper::GetDistanceToNearestAlly(pos,_unit->getID());
int useAlly = 0;
if(_parameters.da < _variables.ALLYDISTANCE_CONSTANT)
	useAlly = 1;

ally += (double)_variables.FORCEALLY*(double)(2*_parameters.da - _parameters.dua)*useAlly;
allyQ += (double)(2*_parameters.da - _parameters.dua)*useAlly;
\end{Sourcecode}	
	In \textit{Ally units} at \lnnum{1} we use a function called \textit{MathHelper::GetDistanceToNearestAlly} which takes as input a tile position and the id of the current unit. We need the unit id because the function iterates trough all our units and we want to avoid calculating the distance to the current unit. If we did not use the unit id we would then always get the distance from the current unit to it self, because the distance would always be less then the distance to other units. \textit{Ally units} can be seen in figure \ref{fig:AU}.
	
		\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Allyunits.png}
			{Repulsion of ally units}{fig:AU}{-3in}

	\subsection{Edges and cliffs (Repulsive)}
	\begin{Sourcecode}[caption=Edges and cliffs]
(*@\lnote@*)_parameters.duc= (int)MathHelper::GetDistanceBetweenPositions(BWTA::getNearestUnwalkablePosition(pos),pos);
(*@\lnote@*)_parameters.dc = (int)MathHelper::GetDistanceBetweenPositions(BWTA::getNearestUnwalkablePosition(pos),_unit->getPosition());

int useEdge = 1;
if(_parameters.duc > _variables.EDGESDISTANCE_CONSTANT)
	useEdge = 0;

edge += (_variables.FORCEEDGE)*(2*_parameters.dc-_parameters.duc)*useEdge;
edgeQ += (2*_parameters.dc-_parameters.duc)*useEdge;
\end{Sourcecode}	
    In \lnnum{1} we use the function \textit{MathHelper::GetDistanceBetweenPositions} to get the distance between the nearest unwalkable position and the current tile. To get the nearest unwalkable position we use the build in function \textit{BWTA::getNearestUnwalkablePosition} which takes as input a position and then find the nerest unwalkable position.

	
	Normaly \textit{dc} from \lnnum{2} would be calculated in the initialization but because \\ \textit{BWTA::getNearestUnwalkablePosition} should depend on the current tile we have to recalculate it for each tile. The resaon is that for each tile the nearest unwalkable position can differ, and we need to use the same unwalkable position in the calculation of the center tile. If we didnt do this, there could be cases where 
	we took the wrong tiles into consideration. An example could be a corner, where some tile would depend on one side, and other tiles on the other side.
	
	The \textit{Edges and cliffs} can be seen in figure \ref{fig:EC}

	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/EdgesAndCliffs.png}
			{Repulsion from cliffs}{fig:EC}{-3in}
