\section{Implementing potential fields}
	
	\subsection{General structure}
	%TALK ABOUT 
	initialization.
	 %_variables
	 %_parameters
	 
	
	\subsection{Squad center}	
		\begin{Sourcecode}[caption=Squad center]
(*@\lnote@*)int dsv = pos.getApproxDistance(_parameters.squadPos);	
int useSquad = 0;
(*@\lnote@*)if(_parameters.ds > _variables.SQUADDISTANCE_CONSTANT)
	useSquad = 1;

(*@\lnote@*)squad += ((double)_variables.FORCESQUAD * (2*(double)_parameters.ds-(double)dsv))*useSquad;
(*@\lnote@*)squadQ += (2*(double)_parameters.ds-(double)dsv)*useSquad;
\end{Sourcecode}
		In \lnnum{1} we calculate \textit{dsv} by using the build in function getApproxDistance which returns the distance between two tiles as an integer. \textit{pos} is the current tile we want to calculate the potential for and \textit{squadPos} is the tile in the center of the squad.
		
		Then in \lnnum{2} we check weather or not to use the \textit{Squad center} which depends on the distance from the unit, know as \textit{ds}, to the center of the squad. This is used to handle the two cases found in the design of the potential field.
		
		Afterwards we calculate the potential in \lnnum{3} where \textit{\_variables.FORCESQUAD} is $f_{S}$. Unlike in the design we times useSquad on the end, this is to make it zero if we don't want to use potential field, which would make the entire calculation become zero. This is way to control the use of the potential field is not only used in \textit{Squad center} but also in all the other potential fields.
		
		\textit{squadQ} in \lnnum{4} and likewise will be explained in the implementation of reinforcement learning in section \ref{section:reinforcement} !!!!!!!!!!!!!!!!!!!!!!!! FIX REF !!!!!!!!!!!!!!!
		
		The \textit{Squad center} implemented and running can be seen in figure \ref{fig:SCA}.
\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Squadcenter.png}
			{Squad center}{fig:SCA}{-3in}
			
	\subsection{Maximum distance positioning}
		\begin{Sourcecode}[caption=Maximum distance]
(*@\lnote@*)int distanceToEnemyFromUnit = _parameters.de;
(*@\lnote@*)int due = MathHelper::GetDistanceToNearestEnemy(pos);
(*@\lnote@*)int correctedDistance = (2*_parameters.de - due);
int useMaxDist = 1;
if(_parameters.sv > distanceToEnemyFromUnit)
	useMaxDist = 0;

(*@\lnote@*)maxdist += ((double)_variables.FORCEMAXDIST * (double)correctedDistance)*(double)useMaxDist;
maxdistQ += (double)(correctedDistance)*(double)useMaxDist;
\end{Sourcecode}
	%TEXT
	
	In \textit{Maximum distance positioning} we start by calculating \textit{de} and \textit{due }in \lnnum{1} \lnnum{2}. These are used to calculate $(2*de - due)$ in \lnnum{3}, known in the code as \textit{correctedDistance}. 
	
	\textit{correctedDistance} is being calculated even if we don't use \textit{Maximum distance positioning} because its also used in \textit{Weapon cool down}. 
	
	In \lnnum{1} and \lnnum{2} we make use of \textit{MathHelper::GetDistanceToNearestEnemy} which is a function that takes a tile as input, and then iterates trough all visible enemies and calculates the distance to there nearest one, and returns it.
	
	The last thing is calculating the potential which is done in \lnnum{4}. The \textit{Maximum distance positioning} implemented and running can be seen in figure \ref{fig:MDP}.

	
	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/MaximumDistance.png}
			{Maximum distance positioning}{fig:MDP}{-3in}

	\subsection{Weapon cool down}
		\begin{Sourcecode}[caption=Weapon cool down]
int toCool = 1;
if(_parameters.wr)
	toCool = 0;
	
cool += _variables.FORCECOOLDOWN*correctedDistance*toCool;
coolQ += correctedDistance*toCool;
\end{Sourcecode}	
	\textit{Weapon cool down} looks a lot like \textit{Maximum distance positioning} and the do almost the same thing, the only difference is when they are applied. An example of \textit{Weapon cool down} can be found in figure \ref{fig:WCD}.
	
	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Weaponscooldown.png}
		{Repulsion from Weapons cool down}{fig:WCD}{-3in}

	\subsection{Ally units}
		\begin{Sourcecode}[caption=Ally units]
(*@\lnote@*)int dua = MathHelper::GetDistanceToNearestAlly(pos,_unit->getID());
int useAlly = 0;
if(_parameters.da < _variables.ALLYDISTANCE_CONSTANT)
	useAlly = 1;

ally += (double)_variables.FORCEALLY*(double)(2*_parameters.da - dua)*useAlly;
allyQ += (double)(2*_parameters.da - dua)*useAlly;
\end{Sourcecode}	
	In \textit{Ally units} at \lnnum{1} we use a function called \textit{MathHelper::GetDistanceToNearestAlly} which takes as input a tile position and the id of the current unit. We need the unit id because the function iterates trough all our units and we want to avoid calculating the distance to the current unit. If we did not use the unit id we would then always get the distance from the current unit to it self, because the distance would always be less then the distance to other units. \textit{Ally units} can be seen in figure \ref{fig:AU}.
	
		\insertmarginfigure{height=2in}{PotentialfieldsImplementation/Allyunits.png}
			{Repulsion of ally units}{fig:AU}{-3in}

	\subsection{Edges and cliffs (Repulsive)}
	\begin{Sourcecode}[caption=Edges and cliffs]
(*@\lnote@*)int duc= (int)MathHelper::GetDistanceBetweenPositions(BWTA::getNearestUnwalkablePosition(pos),pos);
(*@\lnote@*)_parameters.dc = (int)MathHelper::GetDistanceBetweenPositions(BWTA::getNearestUnwalkablePosition(pos),_unit->getPosition());

int useEdge = 1;
if(duc > _variables.EDGESDISTANCE_CONSTANT)
	useEdge = 0;

edge += (_variables.FORCEEDGE)*(2*_parameters.dc-duc)*useEdge;
edgeQ += (2*_parameters.dc-duc)*useEdge;
\end{Sourcecode}	
    In \lnnum{1} we use the function \textit{MathHelper::GetDistanceBetweenPositions} to get the distance between the nearest unwalkable position and the current tile. To get the nearest unwalkable position we use the build in function \textit{BWTA::getNearestUnwalkablePosition} which takes as input a position and then find the nerest unwalkable position.

	Normaly \textit{dc} from \lnnum{2} would be calculated in the initialization but because \\ \textit{BWTA::getNearestUnwalkablePosition} should depend on the current tile we have to recalculate it for each tile. The resaon is that for each tile the nearest unwalkable position can differ, and we need to use the same unwalkable position in the calculation of the center tile. If we didnt do this, there could be cases where 
	we took the wrong tiles into consideration. An example could be a corner, where some tile would depend on one side, and other tiles on the other side.
	
	The \textit{Edges and cliffs} can be seen in figure \ref{fig:EC}

	\insertmarginfigure{height=2in}{PotentialfieldsImplementation/EdgesAndCliffs.png}
			{Repulsion from cliffs}{fig:EC}{-3in}
